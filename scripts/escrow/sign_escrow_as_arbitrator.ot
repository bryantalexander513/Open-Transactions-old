#! /usr/local/bin/ot --script

// This temp variable is used for a running "latest copy" of the smart contract, as we 
// construct it here inside this client-side OT script. (Don't confuse the server-side
// scripts, aka the smart contracts, with the client-side scripts :-)
//
var strSmartContract = ""


// These are all functions that will be available to the smart contract itself (on the
// server side--so only the actual smart contract clauses can call these.) 
//
		// ---------------------------------------------------------
		// OT NATIVE FUNCTIONS 
		// (These functions can be called from INSIDE the scripted clauses.)
		//							// Parameters must match as described below. Return value will be as described below.
		//							// -------------------------------------------------------------
//		"set_seconds_until_timer"	// void SetNextProcessTime(String str_seconds_from_now) // if this is <=0, then it sets next process date to 0.
//		"get_remaining_timer"		// std::string GetRemainingTimer() const
/*
 " 6 minutes	==      360 seconds\n"
 "10 minutes	==      600 seconds\n"
 " 1 hour		==     3600 seconds\n"
 " 1 day		==    86400 seconds\n"
 "30 days		==  2592000 seconds\n"
 " 3 months		==  7776000 seconds\n"
 " 6 months		== 15552000 seconds\n\n" 
 "12 months		== 31104000 seconds\n\n" 
 */
//		"move_funds"				// bool MoveAcctFunds(String from_acct_name, String to_acct_name, String str_Amount); // calls OTCronItem::MoveFunds()

//		"get_acct_balance"			// std::string GetAcctBalance(String acct_name);
//		"get_acct_asset_type_id"	// std::string OTSmartContract::GetAssetTypeIDofAcct(String from_acct_name)

//		"stash_funds"				// bool StashAcctFunds(String from_acct_name, String to_stash_name, String str_Amount); // calls StashFunds()
//		"unstash_funds"				// bool UnstashAcctFunds(String to_acct_name, String from_stash_name, String str_Amount); // calls StashFunds( lAmount * (-1) )
//		"get_stash_balance"			// std::string GetStashBalance(String stash_name, String asset_type_id);

//		"send_notice"				// bool SendNoticeToParty(String party_name);
//		"send_notice_to_parties"	// bool SendANoticeToAllParties();

//		"deactivate_contract"		// void DeactivateSmartContract();

		// ---------------------------------------------------------
		// CALLBACKS 
		// (Called by OT at key moments)
		//
//		"party_may_execute_clause"		// This is a function already on OT server, that it will call when it needs the answer (and that YOUR may call also, whether you provide a script override or not.) Todo: security ramifications?
//		"may_execute_clause"			// This is the name of your clause, as provided in THIS example smart contract. (party_may_execute_clause calls this.)
//		"callback_party_may_execute_clause"   <=== THE CALLBACK WITH THIS NAME must be connected to a script clause (with whatever name you want), and then that clause will trigger when the callback is needed.	
		
//		"party_may_cancel_contract"		// This is a function already on OT server, that it will call when it needs the answer (and that you may call also, since the server has a version of it whether you provide the script or not.) Todo: security ramifications?
//		"may_cancel_contract"			// This is the name of your clause, as provided in THIS example smart contract. (party_may_cancel_contract calls this.)
//		"callback_party_may_cancel_contract"  <=== THE CALLBACK WITH THIS NAME must be connected to a script clause (with whatever name you want), and then that clause will trigger when the callback is needed.
//
		// Callback USAGE:	Your clause, in your smart contract, may have whatever name you want. (Within limits.)
		//					There must be a callback entry in the smart contract, linking your clause the the appropriate callback.
		//					The CALLBACK ENTRY uses the names "callback_party_may_execute_clause" and "callback_party_may_cancel_contract".
		//					If you want to call these from INSIDE YOUR SCRIPT, then use the names "party_may_execute_clause" and "party_may_cancel_contract".
		//
		// ---------------------------------------------------------
		// HOOKS:
		//
		// Hooks are not native calls needing to be registered with the script. (Like the above functions are.)
		// Rather, hooks are SCRIPT CLAUSES, that you have a CHOICE to provide inside your SMART CONTRACT.
		// *IF* you have provided those clauses, then OT *WILL* call them, at the appropriate times. (When
		// specific events occur.) Specifically, Hook entries must be in your smartcontract, linking the below 
		// standard hooks to your clauses.
		//
//	"cron_process"		// Called regularly in OTSmartContract::ProcessCron() based on SMART_CONTRACT_PROCESS_INTERVAL.
//	"cron_activate"		// Done. This is called when the contract is first activated.




// ***************************************************************

// CLIENT-SIDE API CALLS AVAILABLE:

// FYI, here is a list of all the OT API functions that you can call from inside
// your OT scripts on the CLIENT SIDE...

/*


		pScript->chai.add(fun(&OT_CLI_ReadLine), "OT_CLI_ReadLine");			// String OT_CLI_ReadLine()		// Reads from cin until Newline.
		pScript->chai.add(fun(&OT_CLI_ReadUntilEOF), "OT_CLI_ReadUntilEOF");	// String OT_CLI_ReadUntilEOF()	// Reads from cin until EOF.
		// ------------------------------------------------------------------
		
		pScript->chai.add(fun(&OTAPI_Wrap::CreateNym), "OT_API_CreateNym");
        pScript->chai.add(fun(&OTAPI_Wrap::AddServerContract), "OT_API_AddServerContract");
        pScript->chai.add(fun(&OTAPI_Wrap::AddAssetContract), "OT_API_AddAssetContract");
        pScript->chai.add(fun(&OTAPI_Wrap::GetServerCount), "OT_API_GetServerCount");
        pScript->chai.add(fun(&OTAPI_Wrap::GetAssetTypeCount), "OT_API_GetAssetTypeCount");
        pScript->chai.add(fun(&OTAPI_Wrap::GetAccountCount), "OT_API_GetAccountCount");
        pScript->chai.add(fun(&OTAPI_Wrap::GetNymCount), "OT_API_GetNymCount");
        pScript->chai.add(fun(&OTAPI_Wrap::GetServer_ID), "OT_API_GetServer_ID");
        pScript->chai.add(fun(&OTAPI_Wrap::GetServer_Name), "OT_API_GetServer_Name");
        pScript->chai.add(fun(&OTAPI_Wrap::GetAssetType_ID), "OT_API_GetAssetType_ID");
        pScript->chai.add(fun(&OTAPI_Wrap::GetAssetType_Name), "OT_API_GetAssetType_Name");

		pScript->chai.add(fun(&OTAPI_Wrap::GetAccountWallet_ID), "OT_API_GetAccountWallet_ID");
		pScript->chai.add(fun(&OTAPI_Wrap::GetAccountWallet_Name), "OT_API_GetAccountWallet_Name");
		pScript->chai.add(fun(&OTAPI_Wrap::GetAccountWallet_Balance), "OT_API_GetAccountWallet_Balance");
		pScript->chai.add(fun(&OTAPI_Wrap::GetAccountWallet_Type), "OT_API_GetAccountWallet_Type");
		pScript->chai.add(fun(&OTAPI_Wrap::GetAccountWallet_AssetTypeID), "OT_API_GetAccountWallet_AssetTypeID");
		pScript->chai.add(fun(&OTAPI_Wrap::GetAccountWallet_ServerID), "OT_API_GetAccountWallet_ServerID");
		pScript->chai.add(fun(&OTAPI_Wrap::GetAccountWallet_NymID), "OT_API_GetAccountWallet_NymID");
		pScript->chai.add(fun(&OTAPI_Wrap::VerifyAccountReceipt), "OT_API_VerifyAccountReceipt");
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_TransactionNumCount), "OT_API_GetNym_TransactionNumCount");
		
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_ID), "OT_API_GetNym_ID");
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_Name), "OT_API_GetNym_Name");
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_Stats), "OT_API_GetNym_Stats");
		pScript->chai.add(fun(&OTAPI_Wrap::IsNym_RegisteredAtServer), "OT_API_IsNym_RegisteredAtServer");
		
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_MailCount), "OT_API_GetNym_MailCount");
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_MailContentsByIndex), "OT_API_GetNym_MailContentsByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_MailSenderIDByIndex), "OT_API_GetNym_MailSenderIDByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_MailServerIDByIndex), "OT_API_GetNym_MailServerIDByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::Nym_RemoveMailByIndex), "OT_API_Nym_RemoveMailByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::Nym_VerifyMailByIndex), "OT_API_Nym_VerifyMailByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutmailCount), "OT_API_GetNym_OutmailCount");
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutmailContentsByIndex), "OT_API_GetNym_OutmailContentsByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutmailRecipientIDByIndex), "OT_API_GetNym_OutmailRecipientIDByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::GetNym_OutmailServerIDByIndex), "OT_API_GetNym_OutmailServerIDByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::Nym_RemoveOutmailByIndex), "OT_API_Nym_RemoveOutmailByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::Nym_VerifyOutmailByIndex), "OT_API_Nym_VerifyOutmailByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::Wallet_CanRemoveServer), "OT_API_Wallet_CanRemoveServer");
		pScript->chai.add(fun(&OTAPI_Wrap::Wallet_RemoveServer), "OT_API_Wallet_RemoveServer");
		pScript->chai.add(fun(&OTAPI_Wrap::Wallet_CanRemoveAssetType), "OT_API_Wallet_CanRemoveAssetType");
		pScript->chai.add(fun(&OTAPI_Wrap::Wallet_RemoveAssetType), "OT_API_Wallet_RemoveAssetType");
		pScript->chai.add(fun(&OTAPI_Wrap::Wallet_CanRemoveNym), "OT_API_Wallet_CanRemoveNym");
		pScript->chai.add(fun(&OTAPI_Wrap::Wallet_RemoveNym), "OT_API_Wallet_RemoveNym");
		pScript->chai.add(fun(&OTAPI_Wrap::Wallet_CanRemoveAccount), "OT_API_Wallet_CanRemoveAccount");
		pScript->chai.add(fun(&OTAPI_Wrap::Wallet_ImportNym), "OT_API_Wallet_ImportNym");

		pScript->chai.add(fun(&OTAPI_Wrap::SetNym_Name), "OT_API_SetNym_Name");
		pScript->chai.add(fun(&OTAPI_Wrap::SetAccountWallet_Name), "OT_API_SetAccountWallet_Name");
		pScript->chai.add(fun(&OTAPI_Wrap::SetAssetType_Name), "OT_API_SetAssetType_Name");
		pScript->chai.add(fun(&OTAPI_Wrap::SetServer_Name), "OT_API_SetServer_Name");
		
		pScript->chai.add(fun(&OTAPI_Wrap::VerifyAndRetrieveXMLContents), "OT_API_VerifyAndRetrieveXMLContents");
		pScript->chai.add(fun(&OTAPI_Wrap::WriteCheque), "OT_API_WriteCheque");
//		pScript->chai.add(fun(&OTAPI_Wrap::ProposePaymentPlan), "OT_API_ProposePaymentPlan");
		pScript->chai.add(fun(&OTAPI_Wrap::ConfirmPaymentPlan), "OT_API_ConfirmPaymentPlan");
		
		pScript->chai.add(fun(&OTAPI_Wrap::LoadUserPubkey), "OT_API_LoadUserPubkey");
		pScript->chai.add(fun(&OTAPI_Wrap::LoadPubkey), "OT_API_LoadPubkey");
		pScript->chai.add(fun(&OTAPI_Wrap::VerifyUserPrivateKey), "OT_API_VerifyUserPrivateKey");
		pScript->chai.add(fun(&OTAPI_Wrap::LoadPurse), "OT_API_LoadPurse");
		pScript->chai.add(fun(&OTAPI_Wrap::LoadMint), "OT_API_LoadMint");
		pScript->chai.add(fun(&OTAPI_Wrap::LoadAssetContract), "OT_API_LoadAssetContract");
		pScript->chai.add(fun(&OTAPI_Wrap::LoadServerContract), "OT_API_LoadServerContract");
		pScript->chai.add(fun(&OTAPI_Wrap::Mint_IsStillGood), "OT_API_Mint_IsStillGood");
		
		pScript->chai.add(fun(&OTAPI_Wrap::IsBasketCurrency), "OT_API_IsBasketCurrency");
		pScript->chai.add(fun(&OTAPI_Wrap::Basket_GetMemberCount), "OT_API_Basket_GetMemberCount");
		pScript->chai.add(fun(&OTAPI_Wrap::Basket_GetMemberType), "OT_API_Basket_GetMemberType");
		pScript->chai.add(fun(&OTAPI_Wrap::Basket_GetMinimumTransferAmount), "OT_API_Basket_GetMinimumTransferAmount");
		pScript->chai.add(fun(&OTAPI_Wrap::Basket_GetMemberMinimumTransferAmount), "OT_API_Basket_GetMemberMinimumTransferAmount");
		
		pScript->chai.add(fun(&OTAPI_Wrap::LoadAssetAccount), "OT_API_LoadAssetAccount");
		pScript->chai.add(fun(&OTAPI_Wrap::LoadInbox), "OT_API_LoadInbox");
		pScript->chai.add(fun(&OTAPI_Wrap::LoadOutbox), "OT_API_LoadOutbox");
		
		pScript->chai.add(fun(&OTAPI_Wrap::Ledger_GetCount), "OT_API_Ledger_GetCount");
		pScript->chai.add(fun(&OTAPI_Wrap::Ledger_CreateResponse), "OT_API_Ledger_CreateResponse");
		pScript->chai.add(fun(&OTAPI_Wrap::Ledger_GetTransactionByIndex), "OT_API_Ledger_GetTransactionByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::Ledger_GetTransactionByID), "OT_API_Ledger_GetTransactionByID");
		pScript->chai.add(fun(&OTAPI_Wrap::Ledger_GetTransactionIDByIndex), "OT_API_Ledger_GetTransactionIDByIndex");
		pScript->chai.add(fun(&OTAPI_Wrap::Ledger_AddTransaction), "OT_API_Ledger_AddTransaction");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_CreateResponse), "OT_API_Transaction_CreateResponse");
		pScript->chai.add(fun(&OTAPI_Wrap::Ledger_FinalizeResponse), "OT_API_Ledger_FinalizeResponse");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetType), "OT_API_Transaction_GetType");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetVoucher), "OT_API_Transaction_GetVoucher");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetSuccess), "OT_API_Transaction_GetSuccess");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetBalanceAgreementSuccess), "OT_API_Transaction_GetBalanceAgreementSuccess");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetDateSigned), "OT_API_Transaction_GetDateSigned");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetAmount), "OT_API_Transaction_GetAmount");
		pScript->chai.add(fun(&OTAPI_Wrap::Pending_GetNote), "OT_API_Pending_GetNote");
		
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetSenderUserID), "OT_API_Transaction_GetSenderUserID");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetSenderAcctID), "OT_API_Transaction_GetSenderAcctID");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetRecipientUserID), "OT_API_Transaction_GetRecipientUserID");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetRecipientAcctID), "OT_API_Transaction_GetRecipientAcctID");
		pScript->chai.add(fun(&OTAPI_Wrap::Transaction_GetDisplayReferenceToNum), "OT_API_Transaction_GetDisplayReferenceToNum");
		
		pScript->chai.add(fun(&OTAPI_Wrap::CreatePurse), "OT_API_CreatePurse");
		pScript->chai.add(fun(&OTAPI_Wrap::SavePurse), "OT_API_SavePurse");
		pScript->chai.add(fun(&OTAPI_Wrap::Purse_GetTotalValue), "OT_API_Purse_GetTotalValue");
		pScript->chai.add(fun(&OTAPI_Wrap::Purse_Count), "OT_API_Purse_Count");
		pScript->chai.add(fun(&OTAPI_Wrap::Purse_Peek), "OT_API_Purse_Peek");
		pScript->chai.add(fun(&OTAPI_Wrap::Purse_Pop), "OT_API_Purse_Pop");
		pScript->chai.add(fun(&OTAPI_Wrap::Purse_Push), "OT_API_Purse_Push");
		pScript->chai.add(fun(&OTAPI_Wrap::Wallet_ImportPurse), "OT_API_Wallet_ImportPurse");
		pScript->chai.add(fun(&OTAPI_Wrap::exchangePurse), "OT_API_exchangePurse");
		pScript->chai.add(fun(&OTAPI_Wrap::Token_ChangeOwner), "OT_API_Token_ChangeOwner");
		
		pScript->chai.add(fun(&OTAPI_Wrap::Token_GetID), "OT_API_Token_GetID");
		pScript->chai.add(fun(&OTAPI_Wrap::Token_GetDenomination), "OT_API_Token_GetDenomination");
		pScript->chai.add(fun(&OTAPI_Wrap::Token_GetSeries), "OT_API_Token_GetSeries");
		pScript->chai.add(fun(&OTAPI_Wrap::Token_GetValidFrom), "OT_API_Token_GetValidFrom");
		pScript->chai.add(fun(&OTAPI_Wrap::Token_GetValidTo), "OT_API_Token_GetValidTo");
		pScript->chai.add(fun(&OTAPI_Wrap::Token_GetAssetID), "OT_API_Token_GetAssetID");
		pScript->chai.add(fun(&OTAPI_Wrap::Token_GetServerID), "OT_API_Token_GetServerID");
		
		pScript->chai.add(fun(&OTAPI_Wrap::checkServerID), "OT_API_checkServerID");
		pScript->chai.add(fun(&OTAPI_Wrap::createUserAccount), "OT_API_createUserAccount");
		pScript->chai.add(fun(&OTAPI_Wrap::deleteUserAccount), "OT_API_deleteUserAccount");
		pScript->chai.add(fun(&OTAPI_Wrap::deleteAssetAccount), "OT_API_deleteAssetAccount");
		pScript->chai.add(fun(&OTAPI_Wrap::checkUser), "OT_API_checkUser");
		pScript->chai.add(fun(&OTAPI_Wrap::usageCredits), "OT_API_usageCredits");
		pScript->chai.add(fun(&OTAPI_Wrap::sendUserMessage), "OT_API_sendUserMessage");
		
		pScript->chai.add(fun(&OTAPI_Wrap::getRequest), "OT_API_getRequest");
		pScript->chai.add(fun(&OTAPI_Wrap::getTransactionNumber), "OT_API_getTransactionNumber");
		pScript->chai.add(fun(&OTAPI_Wrap::issueAssetType), "OT_API_issueAssetType");
		pScript->chai.add(fun(&OTAPI_Wrap::getContract), "OT_API_getContract");
		pScript->chai.add(fun(&OTAPI_Wrap::getMint), "OT_API_getMint");
		pScript->chai.add(fun(&OTAPI_Wrap::createAssetAccount), "OT_API_createAssetAccount");
		pScript->chai.add(fun(&OTAPI_Wrap::getAccount), "OT_API_getAccount");
		pScript->chai.add(fun(&OTAPI_Wrap::GenerateBasketCreation), "OT_API_GenerateBasketCreation");
		
		pScript->chai.add(fun(&OTAPI_Wrap::AddBasketCreationItem), "OT_API_AddBasketCreationItem");
		pScript->chai.add(fun(&OTAPI_Wrap::issueBasket), "OT_API_issueBasket");
		pScript->chai.add(fun(&OTAPI_Wrap::GenerateBasketExchange), "OT_API_GenerateBasketExchange");
		pScript->chai.add(fun(&OTAPI_Wrap::AddBasketExchangeItem), "OT_API_AddBasketExchangeItem");
		pScript->chai.add(fun(&OTAPI_Wrap::exchangeBasket), "OT_API_exchangeBasket");
		pScript->chai.add(fun(&OTAPI_Wrap::notarizeWithdrawal), "OT_API_notarizeWithdrawal");
		pScript->chai.add(fun(&OTAPI_Wrap::notarizeDeposit), "OT_API_notarizeDeposit");
		pScript->chai.add(fun(&OTAPI_Wrap::notarizeTransfer), "OT_API_notarizeTransfer");
		pScript->chai.add(fun(&OTAPI_Wrap::getInbox), "OT_API_getInbox");
		pScript->chai.add(fun(&OTAPI_Wrap::getOutbox), "OT_API_getOutbox");
		pScript->chai.add(fun(&OTAPI_Wrap::getNymbox), "OT_API_getNymbox");
		pScript->chai.add(fun(&OTAPI_Wrap::LoadNymbox), "OT_API_LoadNymbox");
		pScript->chai.add(fun(&OTAPI_Wrap::processInbox), "OT_API_processInbox");
		pScript->chai.add(fun(&OTAPI_Wrap::processNymbox), "OT_API_processNymbox");
		pScript->chai.add(fun(&OTAPI_Wrap::withdrawVoucher), "OT_API_withdrawVoucher");
		
		pScript->chai.add(fun(&OTAPI_Wrap::depositCheque), "OT_API_depositCheque");
		pScript->chai.add(fun(&OTAPI_Wrap::depositPaymentPlan), "OT_API_depositPaymentPlan");
//		pScript->chai.add(fun(&OTAPI_Wrap::issueMarketOffer), "OT_API_issueMarketOffer");
		pScript->chai.add(fun(&OTAPI_Wrap::getMarketList), "OT_API_getMarketList");
		pScript->chai.add(fun(&OTAPI_Wrap::getMarketOffers), "OT_API_getMarketOffers");
		pScript->chai.add(fun(&OTAPI_Wrap::getMarketRecentTrades), "OT_API_getMarketRecentTrades");
		pScript->chai.add(fun(&OTAPI_Wrap::getNym_MarketOffers), "OT_API_getNym_MarketOffers");
		pScript->chai.add(fun(&OTAPI_Wrap::cancelMarketOffer), "OT_API_cancelMarketOffer");
		pScript->chai.add(fun(&OTAPI_Wrap::cancelPaymentPlan), "OT_API_cancelPaymentPlan");
		
		pScript->chai.add(fun(&OTAPI_Wrap::PopMessageBuffer), "OT_API_PopMessageBuffer");
		pScript->chai.add(fun(&OTAPI_Wrap::FlushMessageBuffer), "OT_API_FlushMessageBuffer");
		pScript->chai.add(fun(&OTAPI_Wrap::Message_GetCommand), "OT_API_Message_GetCommand");
		pScript->chai.add(fun(&OTAPI_Wrap::Message_GetSuccess), "OT_API_Message_GetSuccess");
		pScript->chai.add(fun(&OTAPI_Wrap::Message_GetDepth), "OT_API_Message_GetDepth");
		pScript->chai.add(fun(&OTAPI_Wrap::Message_GetUsageCredits), "OT_API_Message_GetUsageCredits");
		pScript->chai.add(fun(&OTAPI_Wrap::Message_GetTransactionSuccess), "OT_API_Message_GetTransactionSuccess");
		pScript->chai.add(fun(&OTAPI_Wrap::Message_GetBalanceAgreementSuccess), "OT_API_Message_GetBalanceAgreementSuccess");
		pScript->chai.add(fun(&OTAPI_Wrap::Message_GetLedger), "OT_API_Message_GetLedger");
		pScript->chai.add(fun(&OTAPI_Wrap::Message_GetNewAssetTypeID), "OT_API_Message_GetNewAssetTypeID");
		pScript->chai.add(fun(&OTAPI_Wrap::Message_GetNewIssuerAcctID), "OT_API_Message_GetNewIssuerAcctID");
		pScript->chai.add(fun(&OTAPI_Wrap::Message_GetNewAcctID), "OT_API_Message_GetNewAcctID");
		
		pScript->chai.add(fun(&OTAPI_Wrap::Create_SmartContract), "OT_API_Create_SmartContract");
		
		pScript->chai.add(fun(&OTAPI_Wrap::SmartContract_AddBylaw), "OT_API_SmartContract_AddBylaw");
		pScript->chai.add(fun(&OTAPI_Wrap::SmartContract_AddClause), "OT_API_SmartContract_AddClause");
		pScript->chai.add(fun(&OTAPI_Wrap::SmartContract_AddVariable), "OT_API_SmartContract_AddVariable");
		pScript->chai.add(fun(&OTAPI_Wrap::SmartContract_AddCallback), "OT_API_SmartContract_AddCallback");
		pScript->chai.add(fun(&OTAPI_Wrap::SmartContract_AddHook), "OT_API_SmartContract_AddHook");
		
		pScript->chai.add(fun(&OTAPI_Wrap::SmartContract_AddParty), "OT_API_SmartContract_AddParty");
		pScript->chai.add(fun(&OTAPI_Wrap::SmartContract_AddAccount), "OT_API_SmartContract_AddAccount");

		pScript->chai.add(fun(&OTAPI_Wrap::SmartContract_ConfirmAccount), "OT_API_SmartContract_ConfirmAccount");
		pScript->chai.add(fun(&OTAPI_Wrap::SmartContract_ConfirmParty), "OT_API_SmartContract_ConfirmParty");
		
		pScript->chai.add(fun(&OTAPI_Wrap::SmartContract_CountNumsNeeded), "OT_API_SmartContract_CountNumsNeeded");
		pScript->chai.add(fun(&OTAPI_Wrap::HarvestClosingNumbers), "OT_API_HarvestClosingNumbers");
		pScript->chai.add(fun(&OTAPI_Wrap::HarvestAllNumbers), "OT_API_HarvestAllNumbers");
		
		pScript->chai.add(fun(&OTAPI_Wrap::activateSmartContract), "OT_API_activateSmartContract");
		pScript->chai.add(fun(&OTAPI_Wrap::triggerClause), "OT_API_triggerClause");
*/


// ABOVE COMMENTS ARE ONLY "FYI" ...


// ***************************************************************




// GETTING STARTED...

// Here are the actual scripts (the CLAUSES) that will be attached to this SMART CONTRACT.
// There's not much to them -- just testing right now.
//

// -------------------------------
// A TYPICAL CLAUSE...
//
var strCode_typical_clause = " print(\"Hello world (from typical_clause)\") "

// ------------------------------------------------
// HOOK: CRON ACTIVATE  (The smart contract is being activated for the FIRST TIME, on the server.)
//
var strCode_activate_clause = " print(\"SMART CONTRACT: OnActivate(), FYI, is happening/happened, as of this log. (from cron_activate hook)\") "

// ----------------------------------------------------
// HOOK: CRON PROCESS (The smart contract is processing regularly, or according to its timer.)
//
var strCode_process_clause = " var bVar =  move_funds(alice_acct, bob_acct, \"100\"); " // paymentReceipts should show up in the inboxes...

// ----------------------------------------------------
// CALLBACK:  MAY EXECUTE?  (One of the parties is trying to trigger a clause directly. The server is asking you whether this is okay. You must return bool.)
// param_party_name and param_clause_name will be available inside script.
//
var strCode_may_execute_clause = " print(\"MAY EXECUTE? (from may_execute_clause callback. Returning true from script.)\"); true; "

// ----------------------------------------------------
// CALLBACK:  MAY CANCEL?  Server is asking you whether a given party has the power to cancel the contract. You must return bool.
// param_party_name will be available inside script.
//
var strCode_may_cancel_contract = "  print(\"MAY CANCEL? (from may_cancel_contract callback. Returning false from script.)\"); false; "  // need to test this.




// --------------------------------------------------

var BobsUserID = "lMTANg3U97bwGFJAYKljTXAcy5By6JcLdU4di5AoA4z"
var BobsAcctID = "pFPRBfwtq0cXHgQVdbv0TZZOUlP3exSta4hBZNvVub8"


// Just some useful output while running this script:

print("SMART CONTRACT Server: "		+ Server)
print("SMART CONTRACT MyNym: "		+ MyNym)
print("SMART CONTRACT MyAcct: "		+ MyAcct)
print("SMART CONTRACT MyPurse: "	+ MyPurse)

print("SMART CONTRACT Bob's Nym ID: "	+ BobsUserID)
print("SMART CONTRACT Bob's AcctID: "	+ BobsAcctID + "\n")

// ******************************************************************
// CREATE the SMART CONTRACT
//
var strDate1 = "0"
var strDate2 = "0"

var strSmart1 = OT_API_Create_SmartContract(Server, MyNym, strDate1, strDate2)
strSmartContract = strSmart1

// ******************************************************************
// ADD a BYLAW (Clauses, variables, callbacks, and hooks are all attached
// to BYLAWS. FYI, you can add multiple bylaws to each contract.)
//
var strSmart2 = OT_API_SmartContract_AddBylaw(strSmartContract, MyNym, "main_bylaws") // This name "main_bylaws" is used for all API calls related to this Bylaw.

strSmartContract = strSmart2

// ******************************************************************
// ** ADD CLAUSE ** (A CONVENTIONAL CLAUSE) named "typical_clause"
// ...so we can test allowing parties to trigger clauses remotely.
//
var strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"typical_clause",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_typical_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// ******************************************************************
// ** ADD CLAUSE ** FOR HOOK (ACTIVATION) (for "cron_activate" hook, to trigger a clause named "activate_clause")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"activate_clause",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_activate_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// --------------------------------------------------
// ** ADD CLAUSE ** FOR HOOK (TIMER PROCESSING) (for "cron_process" hook, to trigger a clause named "process_clause")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"process_clause",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_process_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// ******************************************************************
// ** Add Clause ** for CALLBACK (for "callback_party_may_execute_clause" callback, clause named "may_execute_clause")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"may_exec_coverage",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_may_execute_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// --------------------------------------------------
// ** Add Clause ** for CALLBACK (for "callback_party_may_cancel_contract" callback, clause named "may_cancel_contract")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"may_cancel_contract",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_may_cancel_contract);	// The actual source code for the clause.
strSmartContract = strSmart3

// ******************************************************************

// ** ADD VARIABLE ** (STRING named str_storage)
// (WHICH STAYS PERSISTENT INSIDE THE CONTRACT.)
// 
var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "strStorage",	// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",		// "constant", "persistent", or "important". Variable access type.
											  "string",			// "string", "long", or "bool".  Variable data type.
											  "This is the default starting value for a string variable in a smart contract...");	// Contains the initial value.
strSmartContract = strSmart4

// --------------------------------------------------
// ** ADD VARIABLE **  (STRING named str_storage2) 

var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "strStorage2",	// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",		// "constant", "persistent", or "important". Variable access type.
											  "string",			// "string", "long", or "bool".  Variable data type.
											  "");				// Contains the initial value. (Empty in this case.)
strSmartContract = strSmart4

// --------------------------------------------------
// ** ADD VARIABLE **  (LONG named lstorage) 
var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "lStorage",	// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",	// "constant", "persistent", or "important". Variable access type.
											  "long",		// "string", "long", or "bool".  Variable data type.
											  "155");		// Contains the initial value.
strSmartContract = strSmart4

// --------------------------------------------------
// ** ADD VARIABLE **  (BOOL named btest) 
var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "bStorage",		// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",	// "constant", "persistent", or "important". Variable access type.
											  "bool",		// "string", "long", or "bool".  Variable data type.
											  "true");		// Contains the initial value.
strSmartContract = strSmart4

// ******************************************************************
// Connect a known CALLBACK to a known CLAUSE  (may EXECUTE clause?)
//
var strSmart5 = OT_API_SmartContract_AddCallback(strSmartContract, MyNym, "main_bylaws",// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "callback_party_may_execute_clause",		// The Callback's name as referenced in the smart contract. (And the scripts...)
											  "may_execute_clause");					// The actual clause that will be triggered by the callback. (Must exist.)
strSmartContract = strSmart5

// --------------------------------------------------
// Connect a known CALLBACK to a known CLAUSE  (may CANCEL contract?)
//
var strSmart5 = OT_API_SmartContract_AddCallback(strSmartContract, MyNym, "main_bylaws",// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "callback_party_may_cancel_contract",		// The Callback's name as referenced in the smart contract. (And the scripts...)
											  "may_cancel_contract");					// The actual clause that will be triggered by the callback. (Must exist.)
strSmartContract = strSmart5

// ******************************************************************
// Connect a known HOOK (ACTIVATE aka "cron_activate") to a known CLAUSE aka "activate_clause"
//
var strSmart6 = OT_API_SmartContract_AddHook(strSmartContract, MyNym, "main_bylaws",		// Should already be on the contract. (This way we can find it.)
										  // ----------------------------------------
										  "cron_activate",		// The Hook's name as referenced in the smart contract. (And the scripts...)
										  "activate_clause");	// The actual clause that will be triggered by the hook. (You can call this multiple times, and have multiple clauses trigger on the same hook.)
strSmartContract = strSmart6

// ----------------------------------------
// Connect a known HOOK (TIMER PROCESSING aka "cron_process") to a known CLAUSE aka "process_clause" 
//
strSmart6 = OT_API_SmartContract_AddHook(strSmartContract, MyNym, "main_bylaws",		// Should already be on the contract. (This way we can find it.)
										  // ----------------------------------------
										  "cron_process",		// The Hook's name as referenced in the smart contract. (And the scripts...)
										  "process_clause");	// The actual clause that will be triggered by the hook. (You can call this multiple times, and have multiple clauses trigger on the same hook.)
strSmartContract = strSmart6
// ----------------------------------------


// ******************************************************************
// Add a THEORETICAL PARTY to the SMART CONTRACT
//
var strSmart7 = OT_API_SmartContract_AddParty(strSmartContract, MyNym, // Need a signer Nym, so it can save. This is unrelated to the party. Use any Nym.
											"party_alice",		// The Party's NAME as referenced in the smart contract. (And the scripts...)
										   // ----------------------------------------
										   "agent_alice");	// An AGENT will be added by default for this party. Need Agent NAME.
										   // (FYI, that is basically the only option, until I code Entities and Roles. Until then, a party can ONLY be
										   // a Nym, with himself as the agent representing that same party. Nym ID is supplied on ConfirmParty() below.)
strSmartContract = strSmart7


// ----------------------------------------
// Add a THEORETICAL ACCOUNT to the SMART CONTRACT
//
var strSmart8 = OT_API_SmartContract_AddAccount(strSmartContract, MyNym, 
												"party_alice",	// The Party's NAME as referenced in the smart contract. (And the scripts...)
												// ----------------------------------------
												"alice_acct",	// The Account's name as referenced in the smart contract
												MyPurse);		// Asset Type ID for the Account.
strSmartContract = strSmart8

// ******************************************************************
// Add a THEORETICAL PARTY to the SMART CONTRACT
//
var strSmart7 = OT_API_SmartContract_AddParty(strSmartContract, BobsUserID, // Need a signer Nym, so it can save. This is unrelated to the party. Use any Nym.
											"party_bob",		// The Party's NAME as referenced in the smart contract. (And the scripts...)
										   // ----------------------------------------
										   "agent_bob");	// An AGENT will be added by default for this party. Need Agent NAME.
										   // (FYI, that is basically the only option, until I code Entities and Roles. Until then, a party can ONLY be
										   // a Nym, with himself as the agent representing that same party. Nym ID is supplied on ConfirmParty() below.)
strSmartContract = strSmart7


// ----------------------------------------
// Add a THEORETICAL ACCOUNT to the SMART CONTRACT
//
var strSmart8 = OT_API_SmartContract_AddAccount(strSmartContract, BobsUserID, // Need a signer Nym, so it can save. This is unrelated to the party. Use any Nym.
												"party_bob",	// The Party's NAME as referenced in the smart contract. (And the scripts...)
												// ----------------------------------------
												"bob_acct",		// The Account's name as referenced in the smart contract
												MyPurse);		// Both accounts, in this script, have the same asset type ID.
strSmartContract = strSmart8


print(strSmartContract)

// ******************************************************************

// This is where we go from creating a generic template, to actually instantiating the
// contract for specific users in a specific situation!
//

// BY THIS POINT, if we're going to ACTIVATE this up-until-now purely THEORETICAL 
// smart contract, using ACTUAL Nyms and Accounts, then we need to check and see
// if they have enough transaction numbers to move forward!
//
// -----------------------------------------------
//
// We'll start with Alice...

var numCountNymAlice = OT_API_GetNym_TransactionNumCount(Server, MyNym)
print("  numCountNymAlice: ")
print(numCountNymAlice)

var numCountNeededAlice = OT_API_SmartContract_CountNumsNeeded(strSmartContract, "agent_alice") + 1
print("  numCountNeededAlice: ")
print(numCountNeededAlice)
// -----------------------------------------------

if (numCountNymAlice >= numCountNeededAlice)
{
	print("Confirming account...")

	// CONFIRM A THEORETICAL ACCT BY GIVING IT A REAL ACCT ID. (Alice's account)
	//
	var strSmart9 = OT_API_SmartContract_ConfirmAccount(strSmartContract, MyNym, "party_alice",	// Should already be on the contract. (This way we can find it.)
														// ----------------------------------------
														"alice_acct",	// Acct name. Should already be added on the contract. (This way we can find it.)
														"agent_alice",	// The agent name for this asset account.
														MyAcct);		// AcctID for the asset account. (For acct_name).
	strSmartContract = strSmart9
	// --------------------------------------------------


print("SMART CONTRACT just confirmed alice_acct for party_alice. Output:\n\n\n")
print(strSmartContract)
print("\n\n\n Confirming party...")

	// --------------------------------------------------
	// CONFIRM A THEORETICAL PARTY BY GIVING IT A REAL NYM ID
	//
	var strSmart10 = OT_API_SmartContract_ConfirmParty(	strSmartContract,	// The smart contract, about to be changed by this function.
														"party_alice",		// The party should already be on the contract. This way we can find it.
														// ----------------------------------------
														MyNym);		// Nym ID for the party, the actual owner, 
																	// ===> AS WELL AS for the default AGENT of that party.
	strSmartContract = strSmart10

	// --------------------------------------------------
}
else
{
	print("\n\n** Sorry -- Alice doesn't have enough transaction numbers to confirm/activate this smart contract. Come back when you have more.\n\n")
}


// ******************************************************************


// Next we have to check Bob...


var numCountNymBob = OT_API_GetNym_TransactionNumCount(Server, BobsUserID)
print("  numCountNymBob: ")
print(numCountNymBob)

var numCountNeededBob = OT_API_SmartContract_CountNumsNeeded(strSmartContract, "agent_bob") + 1
print("  numCountNeededBob: ")
print(numCountNeededBob)

if (numCountNymBob >= numCountNeededBob)
{
	print("Confirming Bob's account...")
	
	// CONFIRM A THEORETICAL ACCT BY GIVING IT A REAL ACCT ID. (Bob's account.)
	//
	var strSmart9 = OT_API_SmartContract_ConfirmAccount(strSmartContract, BobsUserID, "party_bob",	// Should already be on the contract. (This way we can find it.)
														// ----------------------------------------
														"bob_acct",		// Acct name. Should already be added on the contract. (This way we can find it.)
														"agent_bob",	// The agent name for this asset account.
														BobsAcctID);	// AcctID for the asset account. (For acct_name).
	strSmartContract = strSmart9
	// --------------------------------------------------


print("SMART CONTRACT just confirmed bob_acct acct for party_bob. Output:\n\n\n")
print(strSmartContract)
print("\n\n\n Confirming party...")

	// --------------------------------------------------
	// CONFIRM A THEORETICAL PARTY BY GIVING IT A REAL NYM ID
	//
	var strSmart10 = OT_API_SmartContract_ConfirmParty(	strSmartContract,	// The smart contract, about to be changed by this function.
														"party_bob",		// The party should already be on the contract. This way we can find it.
														// ----------------------------------------
														BobsUserID);	// Nym ID for the party, the actual owner, 
																		// ===> AS WELL AS for the default AGENT of that party.
	strSmartContract = strSmart10
}
else
{
	print("\n\n** Sorry -- Bob doesn't have enough transaction numbers to confirm/activate this smart contract. Come back when you have more.\n\n")
}


// ******************************************************************

// If BOTH Nyms had enough transaction #s to go through with it, then...
//
// ...WE ACTIVATE THE SMART CONTRACT!
//

if ((numCountNymBob >= numCountNeededBob) && (numCountNymAlice >= numCountNeededAlice))
{

	print("SMART CONTRACT:  Final version before activation:\n\n\n")
	print(strSmartContract)
	print("\n\n\n Activating...")


	// --------------------------------------------------
	// ACTIVATE THE SMART CONTRACT ON A SERVER.

	OT_API_activateSmartContract(Server, MyNym, strSmartContract);
	
	print("Finishing calling activate!!")
}

// OTHERWISE, I take the transaction numbers BACK! (Also, if the activation failed,
// I'd probably want to take the closing numbers back in that case as well.)

else
{
	print("SMART CONTRACT:  I guess someone didn't have enough transaction numbers, so I'm clawing all the numbers BACK now (that way my data stays good.)")
	
	OT_API_HarvestAllNumbers(Server, MyNym,			strSmartContract);
	OT_API_HarvestAllNumbers(Server, BobsUserID,	strSmartContract);
}


/*
// ******************************************************************
// TRIGGER A CLAUSE REMOTELY (ON A SMART CONTRACT THAT'S ALREADY BEEN ACTIVATED.)
//
// OT_API_triggerClause(Server, MyNym, const char * TRANSACTION_NUMBER, "typical_clause");

*/





















