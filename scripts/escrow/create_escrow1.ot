#! /usr/local/bin/ot --script


// The goal with this script is to create a GENERIC ==> Escrow <== smart
// contract. Generic, meaning, like a template, which might be activated
// over and over again for different parties.
//
// This particular script only creates the template--it doesn't add
// the actual parties to the agreement, nor does it perform any activation
// on the server.
//
// ***************************************************************


/* Here are the EXACT RULES that I intend to write (in script) into
   the smart contract in order to provide real-world ESCROW:

	---------------------------------------
	1.	BASIC INTENTIONS.
	
	Alice is sending X units of Y currency to Bob, in return for real-world
	consideration, which must be described in a "consideration" constant variable
	on the smart contract. It should also include criteria for deciding whether 
	consideration has been fulfilled, and even examples of this criteria in action
	against sample disputes, with explanations for the decisions made and the
	principles involved. (Winning and losing examples, ideally, will both be
	provided.) Descriptions of winning forms of evidence would be most helpful.
	
	Upon activation, Alice's money is stashed inside the escrow contract.
	
	After D days, the contract automatically fulfills and expires, transfering
	the X units of Y currency (the stashed funds) to Bob, with a final receipt
	going to all parties. (Finished.)
	---------------------------------------
	2.	DISPUTES
	
	Within D days (i.e. before the money has gone to Bob, and the escrow
	contract has completed) Alice has the window of opportunity to file a DISPUTE.
	
	When she does, she has the opportunity to share HER SIDE OF THE STORY
	which is included in the receipt and copied to Bob--as well as to JUDGE JUDY,
	who is the third signatory to the contract! Alice's side of the story should
	include an explanation of what happened, as well as an argument justifying why,
	according to the terms of consideration described on the contract, she is the
	rightful winner of the dispute.
	
	When Alice's dispute receipt appears in Bob's and Judy's inboxes, it begins
	a new timer: Bob now has B days to write a response to Alice's dispute, and
	to provide his own arguments and evidence, based upon the terms in the smart
	contract. If Bob does not respond within B days, then the money is automatically
	transferred back to Alice. (Finished.)
	---------------------------------------
	3.	ARBITRATION
	
	Within B days (i.e. before the money has gone back to Alice, and the dispute
	has closed, and the escrow contract itself has completed) JUDGE JUDY must 
	DECIDE whether the winner is Alice or Bob. There will be a clause on the
	contract, which only she can trigger, and only during a dispute period.
	
	The contract can be designed about what to do if Judy doesn't do her part.
	(But she should -- she is a signer, and the other parties will be able to 
	produce their receipt later to prove she didn't do her job. An example
	escrow contract might send the funds to charity, in this case.)
	
	Once Judy makes her judgment, the funds are moved, the final receipts are
	dropped, and a small cut goes to Judy. (Probably a different fee, depending
	on whether or not she actually had to make a judgment.)
	
*/

// ***************************************************************

// This temp variable is used for a running "latest copy" of the smart contract, as we 
// construct it here inside this client-side OT script. (Don't confuse the server-side
// scripts, aka the smart contracts, with the client-side scripts :-)
//
var strSmartContract = ""

// ***************************************************************




// GETTING STARTED...

// Here are the actual scripts (the CLAUSES) that will be attached to this SMART CONTRACT.
// There's not much to them -- just testing right now.
//

// -------------------------------
// A TYPICAL CLAUSE...
//
var strCode_typical_clause = " print(\"Hello world (from typical_clause)\") "

// ------------------------------------------------
// HOOK: CRON ACTIVATE  (The smart contract is being activated for the FIRST TIME, on the server.)
//
var strCode_activate_clause = " print(\"SMART CONTRACT: OnActivate(), FYI, is happening/happened, as of this log. (from cron_activate hook)\") "

// ----------------------------------------------------
// HOOK: CRON PROCESS (The smart contract is processing regularly, or according to its timer.)
//
var strCode_process_clause = " var bVar =  move_funds(alice_acct, bob_acct, \"100\"); " // paymentReceipts should show up in the inboxes...

// ----------------------------------------------------
// CALLBACK:  MAY EXECUTE?  (One of the parties is trying to trigger a clause directly. The server is asking you whether this is okay. You must return bool.)
// param_party_name and param_clause_name will be available inside script.
//
var strCode_may_execute_clause = " print(\"MAY EXECUTE? (from may_execute_clause callback. Returning true from script.)\"); true; "

// ----------------------------------------------------
// CALLBACK:  MAY CANCEL?  Server is asking you whether a given party has the power to cancel the contract. You must return bool.
// param_party_name will be available inside script.
//
var strCode_may_cancel_contract = "  print(\"MAY CANCEL? (from may_cancel_contract callback. Returning false from script.)\"); false; "  // need to test this.




// --------------------------------------------------

var BobsUserID = "lMTANg3U97bwGFJAYKljTXAcy5By6JcLdU4di5AoA4z"
var BobsAcctID = "pFPRBfwtq0cXHgQVdbv0TZZOUlP3exSta4hBZNvVub8"


// Just some useful output while running this script:

print("SMART CONTRACT Server: "		+ Server)
print("SMART CONTRACT MyNym: "		+ MyNym)
print("SMART CONTRACT MyAcct: "		+ MyAcct)
print("SMART CONTRACT MyPurse: "	+ MyPurse)

print("SMART CONTRACT Bob's Nym ID: "	+ BobsUserID)
print("SMART CONTRACT Bob's AcctID: "	+ BobsAcctID + "\n")

// ******************************************************************
// CREATE the SMART CONTRACT
//
var strDate1 = "0"
var strDate2 = "0"

var strSmart1 = OT_API_Create_SmartContract(Server, MyNym, strDate1, strDate2)
strSmartContract = strSmart1

// ******************************************************************
// ADD a BYLAW (Clauses, variables, callbacks, and hooks are all attached
// to BYLAWS. FYI, you can add multiple bylaws to each contract.)
//
var strSmart2 = OT_API_SmartContract_AddBylaw(strSmartContract, MyNym, "main_bylaws") // This name "main_bylaws" is used for all API calls related to this Bylaw.

strSmartContract = strSmart2

// ******************************************************************
// ** ADD CLAUSE ** (A CONVENTIONAL CLAUSE) named "typical_clause"
// ...so we can test allowing parties to trigger clauses remotely.
//
var strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"typical_clause",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_typical_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// ******************************************************************
// ** ADD CLAUSE ** FOR HOOK (ACTIVATION) (for "cron_activate" hook, to trigger a clause named "activate_clause")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"activate_clause",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_activate_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// --------------------------------------------------
// ** ADD CLAUSE ** FOR HOOK (TIMER PROCESSING) (for "cron_process" hook, to trigger a clause named "process_clause")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"process_clause",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_process_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// ******************************************************************
// ** Add Clause ** for CALLBACK (for "callback_party_may_execute_clause" callback, clause named "may_execute_clause")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"may_exec_coverage",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_may_execute_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// --------------------------------------------------
// ** Add Clause ** for CALLBACK (for "callback_party_may_cancel_contract" callback, clause named "may_cancel_contract")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"may_cancel_contract",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_may_cancel_contract);	// The actual source code for the clause.
strSmartContract = strSmart3

// ******************************************************************

// ** ADD VARIABLE ** (STRING named str_storage)
// (WHICH STAYS PERSISTENT INSIDE THE CONTRACT.)
// 
var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "strStorage",	// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",		// "constant", "persistent", or "important". Variable access type.
											  "string",			// "string", "long", or "bool".  Variable data type.
											  "This is the default starting value for a string variable in a smart contract...");	// Contains the initial value.
strSmartContract = strSmart4

// --------------------------------------------------
// ** ADD VARIABLE **  (STRING named str_storage2) 

var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "strStorage2",	// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",		// "constant", "persistent", or "important". Variable access type.
											  "string",			// "string", "long", or "bool".  Variable data type.
											  "");				// Contains the initial value. (Empty in this case.)
strSmartContract = strSmart4

// --------------------------------------------------
// ** ADD VARIABLE **  (LONG named lstorage) 
var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "lStorage",	// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",	// "constant", "persistent", or "important". Variable access type.
											  "long",		// "string", "long", or "bool".  Variable data type.
											  "155");		// Contains the initial value.
strSmartContract = strSmart4

// --------------------------------------------------
// ** ADD VARIABLE **  (BOOL named btest) 
var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "bStorage",		// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",	// "constant", "persistent", or "important". Variable access type.
											  "bool",		// "string", "long", or "bool".  Variable data type.
											  "true");		// Contains the initial value.
strSmartContract = strSmart4

// ******************************************************************
// Connect a known CALLBACK to a known CLAUSE  (may EXECUTE clause?)
//
var strSmart5 = OT_API_SmartContract_AddCallback(strSmartContract, MyNym, "main_bylaws",// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "callback_party_may_execute_clause",		// The Callback's name as referenced in the smart contract. (And the scripts...)
											  "may_execute_clause");					// The actual clause that will be triggered by the callback. (Must exist.)
strSmartContract = strSmart5

// --------------------------------------------------
// Connect a known CALLBACK to a known CLAUSE  (may CANCEL contract?)
//
var strSmart5 = OT_API_SmartContract_AddCallback(strSmartContract, MyNym, "main_bylaws",// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "callback_party_may_cancel_contract",		// The Callback's name as referenced in the smart contract. (And the scripts...)
											  "may_cancel_contract");					// The actual clause that will be triggered by the callback. (Must exist.)
strSmartContract = strSmart5

// ******************************************************************
// Connect a known HOOK (ACTIVATE aka "cron_activate") to a known CLAUSE aka "activate_clause"
//
var strSmart6 = OT_API_SmartContract_AddHook(strSmartContract, MyNym, "main_bylaws",		// Should already be on the contract. (This way we can find it.)
										  // ----------------------------------------
										  "cron_activate",		// The Hook's name as referenced in the smart contract. (And the scripts...)
										  "activate_clause");	// The actual clause that will be triggered by the hook. (You can call this multiple times, and have multiple clauses trigger on the same hook.)
strSmartContract = strSmart6

// ----------------------------------------
// Connect a known HOOK (TIMER PROCESSING aka "cron_process") to a known CLAUSE aka "process_clause" 
//
strSmart6 = OT_API_SmartContract_AddHook(strSmartContract, MyNym, "main_bylaws",		// Should already be on the contract. (This way we can find it.)
										  // ----------------------------------------
										  "cron_process",		// The Hook's name as referenced in the smart contract. (And the scripts...)
										  "process_clause");	// The actual clause that will be triggered by the hook. (You can call this multiple times, and have multiple clauses trigger on the same hook.)
strSmartContract = strSmart6
// ----------------------------------------


// ******************************************************************
// Add a THEORETICAL PARTY to the SMART CONTRACT
//
var strSmart7 = OT_API_SmartContract_AddParty(strSmartContract, MyNym, // Need a signer Nym, so it can save. This is unrelated to the party. Use any Nym.
											"party_alice",		// The Party's NAME as referenced in the smart contract. (And the scripts...)
										   // ----------------------------------------
										   "agent_alice");	// An AGENT will be added by default for this party. Need Agent NAME.
										   // (FYI, that is basically the only option, until I code Entities and Roles. Until then, a party can ONLY be
										   // a Nym, with himself as the agent representing that same party. Nym ID is supplied on ConfirmParty() below.)
strSmartContract = strSmart7


// ----------------------------------------
// Add a THEORETICAL ACCOUNT to the SMART CONTRACT
//
var strSmart8 = OT_API_SmartContract_AddAccount(strSmartContract, MyNym, 
												"party_alice",	// The Party's NAME as referenced in the smart contract. (And the scripts...)
												// ----------------------------------------
												"alice_acct",	// The Account's name as referenced in the smart contract
												MyPurse);		// Asset Type ID for the Account.
strSmartContract = strSmart8

// ******************************************************************
// Add a THEORETICAL PARTY to the SMART CONTRACT
//
var strSmart7 = OT_API_SmartContract_AddParty(strSmartContract, BobsUserID, // Need a signer Nym, so it can save. This is unrelated to the party. Use any Nym.
											"party_bob",		// The Party's NAME as referenced in the smart contract. (And the scripts...)
										   // ----------------------------------------
										   "agent_bob");	// An AGENT will be added by default for this party. Need Agent NAME.
										   // (FYI, that is basically the only option, until I code Entities and Roles. Until then, a party can ONLY be
										   // a Nym, with himself as the agent representing that same party. Nym ID is supplied on ConfirmParty() below.)
strSmartContract = strSmart7


// ----------------------------------------
// Add a THEORETICAL ACCOUNT to the SMART CONTRACT
//
var strSmart8 = OT_API_SmartContract_AddAccount(strSmartContract, BobsUserID, // Need a signer Nym, so it can save. This is unrelated to the party. Use any Nym.
												"party_bob",	// The Party's NAME as referenced in the smart contract. (And the scripts...)
												// ----------------------------------------
												"bob_acct",		// The Account's name as referenced in the smart contract
												MyPurse);		// Both accounts, in this script, have the same asset type ID.
strSmartContract = strSmart8


print(strSmartContract)

// ******************************************************************

// This is where we go from creating a generic template, to actually instantiating the
// contract for specific users in a specific situation!
//

// BY THIS POINT, if we're going to ACTIVATE this up-until-now purely THEORETICAL 
// smart contract, using ACTUAL Nyms and Accounts, then we need to check and see
// if they have enough transaction numbers to move forward!
//
// -----------------------------------------------
//
// We'll start with Alice...

var numCountNymAlice = OT_API_GetNym_TransactionNumCount(Server, MyNym)
print("  numCountNymAlice: ")
print(numCountNymAlice)

var numCountNeededAlice = OT_API_SmartContract_CountNumsNeeded(strSmartContract, "agent_alice") + 1
print("  numCountNeededAlice: ")
print(numCountNeededAlice)
// -----------------------------------------------

if (numCountNymAlice >= numCountNeededAlice)
{
	print("Confirming account...")

	// CONFIRM A THEORETICAL ACCT BY GIVING IT A REAL ACCT ID. (Alice's account)
	//
	var strSmart9 = OT_API_SmartContract_ConfirmAccount(strSmartContract, MyNym, "party_alice",	// Should already be on the contract. (This way we can find it.)
														// ----------------------------------------
														"alice_acct",	// Acct name. Should already be added on the contract. (This way we can find it.)
														"agent_alice",	// The agent name for this asset account.
														MyAcct);		// AcctID for the asset account. (For acct_name).
	strSmartContract = strSmart9
	// --------------------------------------------------


print("SMART CONTRACT just confirmed alice_acct for party_alice. Output:\n\n\n")
print(strSmartContract)
print("\n\n\n Confirming party...")

	// --------------------------------------------------
	// CONFIRM A THEORETICAL PARTY BY GIVING IT A REAL NYM ID
	//
	var strSmart10 = OT_API_SmartContract_ConfirmParty(	strSmartContract,	// The smart contract, about to be changed by this function.
														"party_alice",		// The party should already be on the contract. This way we can find it.
														// ----------------------------------------
														MyNym);		// Nym ID for the party, the actual owner, 
																	// ===> AS WELL AS for the default AGENT of that party.
	strSmartContract = strSmart10

	// --------------------------------------------------
}
else
{
	print("\n\n** Sorry -- Alice doesn't have enough transaction numbers to confirm/activate this smart contract. Come back when you have more.\n\n")
}


// ******************************************************************


// Next we have to check Bob...


var numCountNymBob = OT_API_GetNym_TransactionNumCount(Server, BobsUserID)
print("  numCountNymBob: ")
print(numCountNymBob)

var numCountNeededBob = OT_API_SmartContract_CountNumsNeeded(strSmartContract, "agent_bob") + 1
print("  numCountNeededBob: ")
print(numCountNeededBob)

if (numCountNymBob >= numCountNeededBob)
{
	print("Confirming Bob's account...")
	
	// CONFIRM A THEORETICAL ACCT BY GIVING IT A REAL ACCT ID. (Bob's account.)
	//
	var strSmart9 = OT_API_SmartContract_ConfirmAccount(strSmartContract, BobsUserID, "party_bob",	// Should already be on the contract. (This way we can find it.)
														// ----------------------------------------
														"bob_acct",		// Acct name. Should already be added on the contract. (This way we can find it.)
														"agent_bob",	// The agent name for this asset account.
														BobsAcctID);	// AcctID for the asset account. (For acct_name).
	strSmartContract = strSmart9
	// --------------------------------------------------


print("SMART CONTRACT just confirmed bob_acct acct for party_bob. Output:\n\n\n")
print(strSmartContract)
print("\n\n\n Confirming party...")

	// --------------------------------------------------
	// CONFIRM A THEORETICAL PARTY BY GIVING IT A REAL NYM ID
	//
	var strSmart10 = OT_API_SmartContract_ConfirmParty(	strSmartContract,	// The smart contract, about to be changed by this function.
														"party_bob",		// The party should already be on the contract. This way we can find it.
														// ----------------------------------------
														BobsUserID);	// Nym ID for the party, the actual owner, 
																		// ===> AS WELL AS for the default AGENT of that party.
	strSmartContract = strSmart10
}
else
{
	print("\n\n** Sorry -- Bob doesn't have enough transaction numbers to confirm/activate this smart contract. Come back when you have more.\n\n")
}


// ******************************************************************

// If BOTH Nyms had enough transaction #s to go through with it, then...
//
// ...WE ACTIVATE THE SMART CONTRACT!
//

if ((numCountNymBob >= numCountNeededBob) && (numCountNymAlice >= numCountNeededAlice))
{

	print("SMART CONTRACT:  Final version before activation:\n\n\n")
	print(strSmartContract)
	print("\n\n\n Activating...")


	// --------------------------------------------------
	// ACTIVATE THE SMART CONTRACT ON A SERVER.

	OT_API_activateSmartContract(Server, MyNym, strSmartContract);
	
	print("Finishing calling activate!!")
}

// OTHERWISE, I take the transaction numbers BACK! (Also, if the activation failed,
// I'd probably want to take the closing numbers back in that case as well.)

else
{
	print("SMART CONTRACT:  I guess someone didn't have enough transaction numbers, so I'm clawing all the numbers BACK now (that way my data stays good.)")
	
	OT_API_HarvestAllNumbers(Server, MyNym,			strSmartContract);
	OT_API_HarvestAllNumbers(Server, BobsUserID,	strSmartContract);
}


/*
// ******************************************************************
// TRIGGER A CLAUSE REMOTELY (ON A SMART CONTRACT THAT'S ALREADY BEEN ACTIVATED.)
//
// OT_API_triggerClause(Server, MyNym, const char * TRANSACTION_NUMBER, "typical_clause");

*/





















