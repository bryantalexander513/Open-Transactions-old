#! /usr/local/bin/ot --script

// Used for a running "latest copy" of the smart contract, as we construct it.
//
var strSmartContract = ""

// -------------------------------------------------------

// These are the actual scripts (the clauses) that will be attached to this smart contract.
// Notice there's not much to them -- just testing right now.
//
var strCode_first_clause = " print(\"Hello world (from first_clause)\") "
var strCode_activate_clause = " print(\"SCRIPT ON ACTIVATION!! (from cron_activate hook)\") "
var strCode_process_clause = " var bVar =  move_funds(alice_acct, bob_acct, \"100\"); "
//var strCode_process_clause = " print(\"CALLING MOVE FUNDS...\n\"); move_funds(alice_acct, bob_acct, 100);  "
var strCode_may_exec_coverage = " print(\"MAY EXECUTE? (from may_exec_coverage callback. Returning true from script.)\"); return true; "

// --------------------------------------------------
print("SMART CONTRACT Server: "		+ Server)
print("SMART CONTRACT MyNym: "		+ MyNym)
print("SMART CONTRACT MyAcct: "		+ MyAcct)
print("SMART CONTRACT MyPurse: "	+ MyPurse)

var BobsUserID = "lMTANg3U97bwGFJAYKljTXAcy5By6JcLdU4di5AoA4z"
var BobsAcctID = "qcHaITqTkP3LjQEXT5pmFpDhdvDhY6hgbsMQFDBW85y"

print("SMART CONTRACT Bob's Nym ID: "	+ BobsUserID)
print("SMART CONTRACT Bob's AcctID: "	+ BobsAcctID + "\n")

// ******************************************************************
// CREATE the SMART CONTRACT
//
var strSmart1 = OT_API_Create_SmartContract(Server, MyNym, "", "")
//var strDate1 = "0"
//var strDate2 = "0"
strSmartContract = strSmart1

// ******************************************************************
// ADD a BYLAW (Clauses, variables, callbacks, and hooks are all attached
// to BYLAWS. You can add multiple bylaws to each contract.)
//
var strSmart2 = OT_API_SmartContract_AddBylaw(strSmartContract, MyNym, "main_bylaws")

strSmartContract = strSmart2

// ******************************************************************
// ** ADD CLAUSE ** (A CONVENTIONAL CLAUSE) named "first_clause" so we can test allowing parties to trigger clauses remotely.
//
var strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"first_clause",	// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_first_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// ******************************************************************
// ** ADD CLAUSE ** FOR HOOK (ACTIVATION) (for "cron_activate" hook, to trigger a clause named "activate_clause")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"activate_clause",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_activate_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// --------------------------------------------------
// ** ADD CLAUSE ** FOR HOOK (TIMER PROCESSING) (for "cron_process" hook, to trigger a clause named "process_clause")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"process_clause",			// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_process_clause);	// The actual source code for the clause.
strSmartContract = strSmart3

// ******************************************************************
// ** ADD CLAUSE ** FOR CALLBACK (for "callback_party_may_execute_clause" callback, clause named "may_exec_coverage")
//
strSmart3 = OT_API_SmartContract_AddClause(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											// ----------------------------------------
											"may_exec_coverage",		// The Clause's name as referenced in the smart contract. (And the scripts...)
											strCode_may_exec_coverage);	// The actual source code for the clause.
strSmartContract = strSmart3

// ******************************************************************

// ** ADD VARIABLE ** (string named str_storage)
// (WHICH STAYS PERSISTENT INSIDE THE CONTRACT.)
// 
var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "strStorage",	// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",		// "constant", "persistent", or "important". Variable access type.
											  "string",			// "string", "long", or "bool".  Variable data type.
											  "This is the default starting value for a string variable in a smart contract...");	// Contains the initial value.
strSmartContract = strSmart4

// --------------------------------------------------
// ** ADD VARIABLE **  (string named str_storage2) 

var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "strStorage2",	// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",		// "constant", "persistent", or "important". Variable access type.
											  "string",			// "string", "long", or "bool".  Variable data type.
											  "");				// Contains the initial value. (Empty in this case.)
strSmartContract = strSmart4

// --------------------------------------------------
// ** ADD VARIABLE **  (long named lstorage) 
var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "lStorage",	// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",	// "constant", "persistent", or "important". Variable access type.
											  "long",		// "string", "long", or "bool".  Variable data type.
											  "155");		// Contains the initial value.
strSmartContract = strSmart4

// --------------------------------------------------
// ** ADD VARIABLE **  (bool named btest) 
var strSmart4 = OT_API_SmartContract_AddVariable(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "bStorage",		// The Variable's NAME as referenced in the smart contract. (And the scripts...)
											  // ----------------------------------------
											  "persistent",	// "constant", "persistent", or "important". Variable access type.
											  "bool",		// "string", "long", or "bool".  Variable data type.
											  "true");		// Contains the initial value.
strSmartContract = strSmart4

// ******************************************************************
// CONNECT A KNOWN CALLBACK TO A KNOWN CLAUSE
//
var strSmart5 = OT_API_SmartContract_AddCallback(strSmartContract, MyNym, "main_bylaws",	// Should already be on the contract. (This way we can find it.)
											  // ----------------------------------------
											  "callback_party_may_execute_clause",	// The Callback's name as referenced in the smart contract. (And the scripts...)
											  "may_exec_coverage");					// The actual clause that will be triggered by the callback. (Must exist.)
strSmartContract = strSmart5

// ******************************************************************
// CONNECT A KNOWN HOOK (ACTIVATE) TO A KNOWN CLAUSE
//
var strSmart6 = OT_API_SmartContract_AddHook(strSmartContract, MyNym, "main_bylaws",		// Should already be on the contract. (This way we can find it.)
										  // ----------------------------------------
										  "cron_activate",		// The Hook's name as referenced in the smart contract. (And the scripts...)
										  "activate_clause");	// The actual clause that will be triggered by the hook. (You can call this multiple times, and have multiple clauses trigger on the same hook.)
strSmartContract = strSmart6

// ----------------------------------------
// CONNECT A KNOWN HOOK (TIMER PROCESSING) TO A KNOWN CLAUSE
//
strSmart6 = OT_API_SmartContract_AddHook(strSmartContract, MyNym, "main_bylaws",		// Should already be on the contract. (This way we can find it.)
										  // ----------------------------------------
										  "cron_process",		// The Hook's name as referenced in the smart contract. (And the scripts...)
										  "process_clause");	// The actual clause that will be triggered by the hook. (You can call this multiple times, and have multiple clauses trigger on the same hook.)
strSmartContract = strSmart6
// ----------------------------------------


// ******************************************************************
// ADD A THEORETICAL PARTY TO THE SMART CONTRACT
//
var strSmart7 = OT_API_SmartContract_AddParty(strSmartContract, MyNym, // Need a signer Nym, so it can save. This is unrelated to the party. Use any Nym.
											"party_alice",		// The Party's NAME as referenced in the smart contract. (And the scripts...)
										   // ----------------------------------------
										   "agent_alice");	// An AGENT will be added by default for this party. Need Agent NAME.
										   // (FYI, that is basically the only option, until I code Entities and Roles. Until then, a party can ONLY be
										   // a Nym, with himself as the agent representing that same party. Nym ID is supplied on ConfirmParty() below.)
strSmartContract = strSmart7


// ----------------------------------------
// ADD A THEORETICAL ACCOUNT TO THE SMART CONTRACT
//
var strSmart8 = OT_API_SmartContract_AddAccount(strSmartContract, MyNym, 
												"party_alice",	// The Party's NAME as referenced in the smart contract. (And the scripts...)
												// ----------------------------------------
												"alice_acct",	// The Account's name as referenced in the smart contract
												MyPurse);		// Asset Type ID for the Account.
strSmartContract = strSmart8

// ******************************************************************
// ADD A THEORETICAL PARTY TO THE SMART CONTRACT
//
var strSmart7 = OT_API_SmartContract_AddParty(strSmartContract, BobsUserID, // Need a signer Nym, so it can save. This is unrelated to the party. Use any Nym.
											"party_bob",		// The Party's NAME as referenced in the smart contract. (And the scripts...)
										   // ----------------------------------------
										   "agent_bob");	// An AGENT will be added by default for this party. Need Agent NAME.
										   // (FYI, that is basically the only option, until I code Entities and Roles. Until then, a party can ONLY be
										   // a Nym, with himself as the agent representing that same party. Nym ID is supplied on ConfirmParty() below.)
strSmartContract = strSmart7


// ----------------------------------------
// ADD A THEORETICAL ACCOUNT TO THE SMART CONTRACT
//
var strSmart8 = OT_API_SmartContract_AddAccount(strSmartContract, BobsUserID, 
												"party_bob",	// The Party's NAME as referenced in the smart contract. (And the scripts...)
												// ----------------------------------------
												"bob_acct",		// The Account's name as referenced in the smart contract
												MyPurse);		// Both accounts, in this script, have the same asset type ID.
strSmartContract = strSmart8


print(strSmartContract)

// ******************************************************************

var numCountNymAlice = OT_API_GetNym_TransactionNumCount(Server, MyNym)
print("  numCountNymAlice: ")
print(numCountNymAlice)

var numCountNeededAlice = OT_API_SmartContract_CountNumsNeeded(strSmartContract, "agent_alice") + 1
print("  numCountNeededAlice: ")
print(numCountNeededAlice)
// -----------------------------------------------

if (numCountNymAlice >= numCountNeededAlice)
{
	print("Confirming account...")

	// ******************************************************************
	// CONFIRM A THEORETICAL ACCT BY GIVING IT A REAL ACCT ID.
	//
	var strSmart9 = OT_API_SmartContract_ConfirmAccount(strSmartContract, MyNym, "party_alice",	// Should already be on the contract. (This way we can find it.)
														// ----------------------------------------
														"alice_acct",	// Acct name. Should already be added on the contract. (This way we can find it.)
														"agent_alice",	// The agent name for this asset account.
														MyAcct);		// AcctID for the asset account. (For acct_name).
	strSmartContract = strSmart9
	// --------------------------------------------------


print("SMART CONTRACT just confirmed alice_acct for party_alice. Output:\n\n\n")
print(strSmartContract)
print("\n\n\n Confirming party...")

	// --------------------------------------------------
	// CONFIRM A THEORETICAL PARTY BY GIVING IT A REAL NYM ID
	//
	var strSmart10 = OT_API_SmartContract_ConfirmParty(	strSmartContract,	// The smart contract, about to be changed by this function.
														"party_alice",		// The party should already be on the contract. This way we can find it.
														// ----------------------------------------
														MyNym);		// Nym ID for the party, the actual owner, 
																	// ===> AS WELL AS for the default AGENT of that party.
	strSmartContract = strSmart10

	// --------------------------------------------------
}
else
{
	print("\n\n** Sorry -- Alice doesn't have enough transaction numbers to confirm/activate this smart contract. Come back when you have more.\n\n")
}


// --------------------------------------------------

var numCountNymBob = OT_API_GetNym_TransactionNumCount(Server, BobsUserID)
print("  numCountNymBob: ")
print(numCountNymBob)

var numCountNeededBob = OT_API_SmartContract_CountNumsNeeded(strSmartContract, "agent_bob") + 1
print("  numCountNeededBob: ")
print(numCountNeededBob)

if (numCountNymBob >= numCountNeededBob)
{
	print("Confirming Bob's account...")
	
//var BobsUserID = "lMTANg3U97bwGFJAYKljTXAcy5By6JcLdU4di5AoA4z"
//var BobsAcctID = "qcHaITqTkP3LjQEXT5pmFpDhdvDhY6hgbsMQFDBW85y"

	// ******************************************************************
	// CONFIRM A THEORETICAL ACCT BY GIVING IT A REAL ACCT ID.
	//
	var strSmart9 = OT_API_SmartContract_ConfirmAccount(strSmartContract, BobsUserID, "party_bob",	// Should already be on the contract. (This way we can find it.)
														// ----------------------------------------
														"bob_acct",		// Acct name. Should already be added on the contract. (This way we can find it.)
														"agent_bob",	// The agent name for this asset account.
														BobsAcctID);	// AcctID for the asset account. (For acct_name).
	strSmartContract = strSmart9
	// --------------------------------------------------


print("SMART CONTRACT just confirmed bob_acct acct for party_bob. Output:\n\n\n")
print(strSmartContract)
print("\n\n\n Confirming party...")

	// --------------------------------------------------
	// CONFIRM A THEORETICAL PARTY BY GIVING IT A REAL NYM ID
	//
	var strSmart10 = OT_API_SmartContract_ConfirmParty(	strSmartContract,	// The smart contract, about to be changed by this function.
														"party_bob",		// The party should already be on the contract. This way we can find it.
														// ----------------------------------------
														BobsUserID);	// Nym ID for the party, the actual owner, 
																		// ===> AS WELL AS for the default AGENT of that party.
	strSmartContract = strSmart10
}
else
{
	print("\n\n** Sorry -- Bob doesn't have enough transaction numbers to confirm/activate this smart contract. Come back when you have more.\n\n")
}



// If BOTH Nyms had enough transaction #s to go through with it, then we'll activate the thing.
if ((numCountNymBob >= numCountNeededBob) && (numCountNymAlice >= numCountNeededAlice))
{

	print("SMART CONTRACT:  Final version before activation:\n\n\n")
	print(strSmartContract)
	print("\n\n\n Activating...")


	// --------------------------------------------------
	// ACTIVATE THE SMART CONTRACT ON A SERVER.

	OT_API_activateSmartContract(Server, MyNym, strSmartContract);
	
	print("Finishing calling activate!!")
}
// OTHERWISE, I take the transaction numbers BACK! (Also, if the activation failed,
// I'd probably want to take the closing numbers back in that case as well.)
else
{
	print("SMART CONTRACT:  I guess someone didn't have enough transaction numbers, so I'm clawing all the numbers BACK now (that way my data stays good.)")
	
	OT_API_HarvestAllNumbers(Server, MyNym,			strSmartContract);
	OT_API_HarvestAllNumbers(Server, BobsUserID,	strSmartContract);
}


/*
// ******************************************************************
// TRIGGER A CLAUSE REMOTELY (ON A SMART CONTRACT THAT'S ALREADY BEEN ACTIVATD.)
//
// OT_API_triggerClause(Server, MyNym, const char * TRANSACTION_NUMBER, "first_clause");

*/





















